<hr>
<p><strong>POINT_OBJECT</strong></p>
<hr>


<figure class="wp-block-image size-full"><img data-attachment-id="16887" data-permalink="https://karlinaobject.wordpress.com/point_object/points_on_cartesian_grid/" data-orig-file="https://karlinaobject.files.wordpress.com/2022/07/points_on_cartesian_grid.png" data-orig-size="960,720" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="points_on_cartesian_grid" data-image-description="" data-image-caption="" data-medium-file="https://karlinaobject.files.wordpress.com/2022/07/points_on_cartesian_grid.png?w=300" data-large-file="https://karlinaobject.files.wordpress.com/2022/07/points_on_cartesian_grid.png?w=960" src="https://karlinaobject.files.wordpress.com/2022/07/points_on_cartesian_grid.png" alt="" class="wp-image-16887" /></figure>


<hr>
<p><span style="background:#ffff00;">The C++ program featured in this tutorial web page implements a custom data type (i.e. <strong>class</strong>) named <strong>POINT</strong>. Each POINT type variable (i.e. POINT type <strong>object</strong>) represents exactly one Cartesian plane coordinate pair.</span></p>
<p><strong><em>To view hidden text inside of the preformatted text boxes below, scroll horizontally.</em></strong></p>
<pre>class : object :: data_type : variable.</pre>
<p>Each POINT object has an int type variable named <strong>X</strong> which represents a whole number position along the horizontal axis of the Cartesian plane. </p>
<p>Each POINT object has an int type variable named <strong>Y</strong> which represents a whole number position along the vertical axis of the Cartesian plane.</p>
<hr>
<p><strong>Software Application Files</strong></p>
<hr>
<p>C++ header file: <a style="background:#000000;color:#00ff00;" href="https://github.com/karlinarayberinger/karlina_object_ultimate_starter_pack/blob/main/point.h" target="_blank" rel="noopener">https://github.com/karlinarayberinger/karlina_object_ultimate_starter_pack/blob/main/point.h</a></p>
<p>C++ source file: <a style="background:#000000;color:#00ff00;" href="https://github.com/karlinarayberinger/karlina_object_ultimate_starter_pack/blob/main/point.cpp" target="_blank" rel="noopener">https://github.com/karlinarayberinger/karlina_object_ultimate_starter_pack/blob/main/point.cpp</a></p>
<p>C++ source file: <a style="background:#000000;color:#00ff00;" href="https://github.com/karlinarayberinger/karlina_object_ultimate_starter_pack/blob/main/point_driver.cpp" target="_blank" rel="noopener">https://github.com/karlinarayberinger/karlina_object_ultimate_starter_pack/blob/main/point_driver.cpp</a></p>
<p>plain-text file: <a style="background:#000000;color:#ff9000;" href="https://github.com/karlinarayberinger/karlina_object_ultimate_starter_pack/blob/main/point_driver_output.txt" target="_blank" rel="noopener">https://github.com/karlinarayberinger/karlina_object_ultimate_starter_pack/blob/main/point_driver_output.txt</a></p>
<hr>
<p><strong>Program Compilation &amp; Execution</strong></p>
<hr>
<p>STEP_0: Copy and paste each of the following C++ code files into a new text editor document and save each  document as its respective file name:</p>
<pre>point.h</pre>
<pre>point.cpp</pre>
<pre>point_driver.cpp</pre>
<p>STEP_1: Open a Unix command line terminal application and set the current directory to wherever the C++ is located on the local machine (e.g. Desktop).</p>
<pre>cd Desktop</pre>
<p>STEP_2: Compile the C++ file into machine-executable instructions (i.e. object file) and then into an executable piece of software named <strong>app</strong> using the following command:</p>
<pre>g++ point_driver.cpp point.cpp -o app</pre>
<p>STEP_3: If the program compilation command does not work, then use the following command to install the C++ compiler:</p>
<pre>sudo apt install build-essential</pre>
<p>STEP_4: After running the <strong>g++</strong> command, run the executable file using the following command:</p>
<pre>./app</pre>
<p>STEP_5: Observe program results on the command line terminal and in the <a style="background:#000000;color:#ff9000;" href="https://github.com/karlinarayberinger/karlina_object_ultimate_starter_pack/blob/main/point_driver_output.txt" target="_blank" rel="noopener">output file</a>.</p>
<hr>
<p><strong>POINT Class Declaration</strong></p>
<hr>
<p>C++ header file: <a style="background:#000000;color:#00ff00;" href="https://github.com/karlinarayberinger/karlina_object_ultimate_starter_pack/blob/main/point.h" target="_blank" rel="noopener">https://github.com/karlinarayberinger/karlina_object_ultimate_starter_pack/blob/main/point.h</a></p>
<p><strong><em>When copy-pasting the source code from the preformatted text box below into a text editor document, remove the spaces between the angle brackets and the library names in the preprocessing directives code block.</em></strong></p>
<hr>
<pre>/**
 * file: point.h
 * type: C++ (header file)
 * author: Karlina Ray Beringer
 * date: 30_JULY_2022
 * license: PUBLIC_DOMAIN
 */

// If point.h has not already been linked to a source file (.cpp), then link this header file to the source file(s) which include this header file.
#ifndef POINT_H 
#define POINT_H

#include &lt; iostream &gt; // Include the library which defines command line input and output operations.
#include &lt; fstream &gt; // Include the library which defines file input and output operations.
#include &lt; cmath &gt; // Include the library which defines the square root function, trigonometric functions, and the floor function (i.e. the native C++ function which rounds a number down to its nearest integer).
#include &lt; string &gt; // Include the library which defines sequences of text characters as string type variables.

#define MINIMUM_X -999 // Define the constant MINIMUM_X to represent the value -999.
#define MINIMUM_Y -999 // Define the constant MINIMUM_Y to represent the value -999.
#define MAXIMUM_X 999 // Define the constant MAXIMUM_X to represent the value 999.
#define MAXIMUM_Y 999 // Define the constant MAXIMUM_X to represent the value 999.
#define PI 3.141592653589793238462643383279502884197169399 // Define the constant PI to represent the approximate value of a circle's circumference divided by that circle's diameter.

/**
 * Define a class which is used to instantiate POINT type software objects.
 * 
 * (object : class :: variable : data_type).
 * 
 * A POINT object is a specific data model of a two-dimensional point.
 * 
 * X stores one integer value at a time which is no smaller than MINIMUM_X and which is no larger than MAXIMUM_X.
 * Y stores one integer value at a time which is no smaller than MINIMUM_Y and which is no larger than MAXIMUM_Y.
 * 
 * X represents a specific whole number position along the x-axis (i.e. horizontal dimension) of a two-dimensional Cartesian grid.
 * Y represents a specific whole number position along the y-axis (i.e. vertical dimension) of the same two-dimensional Cartesian grid.
 */
class POINT
{
private:
    int X, Y; // data attributes
public:
    POINT(); // default constructor
    POINT(int X, int Y); // normal constructor
    POINT(const POINT &amp; point); // copy constructor
    int get_X(); // getter method
    int get_Y(); // getter method
    bool set_X(int X); // setter method
    bool set_Y(int Y); // setter method
    double get_distance_from(POINT &amp; point); // getter method
    double get_slope_of_line_to(POINT &amp; point); // getter method
    void print(std::ostream &amp; output = std::cout); // descriptor method
    friend std::ostream &amp; operator &lt;&lt; (std::ostream &amp; output, POINT &amp; point); // descriptor method
    ~POINT(); // destructor
};

// end of header file
#endif
</pre>
<hr>
<p><strong>POINT Class Definition</strong></p>
<hr>
<p>C++ source file: <a style="background:#000000;color:#00ff00;" href="https://github.com/karlinarayberinger/karlina_object_ultimate_starter_pack/blob/main/point.cpp" target="_blank" rel="noopener">https://github.com/karlinarayberinger/karlina_object_ultimate_starter_pack/blob/main/point.cpp</a></p>
<hr>
<pre>/**
 * file: point.cpp
 * type: C++ (source file)
 * date: 30_JULY_2022
 * author: Karlina Ray Beringer
 * license: PUBLIC_DOMAIN 
 */

#include "point.h" // Include the C++ header file which contains preprocessing directives, variable declarations, and function prototypes for the POINT class.

/**
 * The default constructor method of the POINT class instantiates POINT type objects whose X value is set to 0 and whose Y value is set to 0.
 * 
 * The default constructor method of the POINT class is invoked when a POINT type variable is declared as follows:
 * 
 * // variable declaration one
 * POINT point_0; 
 * 
 * // variable declaration two
 * POINT point_1 = POINT();
 */
POINT::POINT()
{
    std::cout &lt;&lt; "\n\nCreating the POINT type object whose memory address is " &lt;&lt; this &lt;&lt; "...";
    X = 0;
    Y = 0;
}

/**
 * The normal constructor method of the POINT class instantiates POINT type objects 
 * whose X value is set to the leftmost function input value (if that input value is in range) and 
 * whose Y value is set to the rightmost function input value (if that input value is in range).
 * 
 * If an input value is out of range, then set the corresponding int-type property of this to 0.
 * 
 * (The keyword this refers to the POINT object which is returned by this function).
 *
 * This normal constructor method of the POINT class is invoked when a POINT type variable is declared as follows:
 * 
 * // non-default POINT definition example one
 * POINT point_2 = POINT(-55,84);
 * 
 * // non-default POINT definition example two
 * POINT point_3 = POINT(3,-4);
 */
POINT::POINT(int X, int Y)
{
    std::cout &lt;&lt; "\n\nCreating the POINT type object whose memory address is " &lt;&lt; this &lt;&lt; "...";
    this -&gt; X = ((X &lt; MINIMUM_X) || (X &gt; MAXIMUM_X)) ? 0 : X; // Set the X property of the POINT instance being created to 0 if the function input X value is out of range.
    this -&gt; Y = ((Y &lt; MINIMUM_Y) || (Y &gt; MAXIMUM_Y)) ? 0 : Y; // Set the Y property of the POINT instance being created to 0 if the function input Y value is out of range.
}

/**
 * The copy constructor method of the POINT class instantiates POINT type objects 
 * whose X value is set to the X value of the input POINT object 
 * and whose Y value is set to the Y value of the input POINT object.
 * 
 * (Note that the input POINT object named point is the predecessor to the object returned by this function).
 * 
 * (The keyword this refers to the POINT object which is returned by this function (i.e. the successor to point)).
 * 
 * The memory address of the predecessor POINT object is passed into the function as the variable named point.
 *
 * This copy constructor method of the POINT class is invoked when a POINT type variable is declared as follows:
 * 
 * // copy POINT definition example one
 * POINT point_4 = POINT(point_3);
 * 
 * // copy POINT definition example two
 * POINT point_5 = POINT(point_4);
 */
POINT::POINT(const POINT &amp; point) 
{
    std::cout &lt;&lt; "\n\nCreating the POINT type object whose memory address is " &lt;&lt; this &lt;&lt; "...";
    X = point.X;
    Y = point.Y;
}

/**
 * The getter method of the POINT class returns the value of the caller POINT object's X property.
 * 
 * X is an int type variable which stores exactly one integer value at a time which is no smaller than MINIMUM_X and which is no larger than MAXIMUM_X.
 */
int POINT::get_X()
{
    return X;
}

/**
 * The getter method of the POINT class returns the value of the caller POINT object's Y property.
 * 
 * Y is an int type variable which stores exactly one integer value at a time which is no smaller than MINIMUM_Y and which is no larger than MAXIMUM_Y.
 */
int POINT::get_Y()
{
    return Y;
}

/**
 * The setter method of the POINT class sets the POINT object's X property to the passed in value if that passed in value is in range.
 * 
 * If the input value is in range, then return true. Otherwise, do not change the caller POINT object's X value and return false.
 */
bool POINT::set_X(int X)
{
    if ((X &gt;= MINIMUM_X) &amp;&amp; (X &lt;= MAXIMUM_X)) 
    {
        this -&gt; X = X;
        return true;
    }
    return false;
}

/**
 * The setter method of the POINT class sets the POINT object's Y property to the passed in value if that passed in value is in range.
 * 
 * If the input value is in range, then return true. Otherwise, do not change the caller POINT object's Y value and return false.
 */
bool POINT::set_Y(int Y)
{
    if ((Y &gt;= MINIMUM_Y) &amp;&amp; (X &lt;= MAXIMUM_Y)) 
    {
        this -&gt; Y = Y;
        return true;
    }
    return false;
}

/**
 * The getter method of the POINT class returns the nonzero length of the shortest path 
 * between the planar point represented by the the caller POINT object (i.e. this) 
 * and the planar point represented by the input POINT instance (i.e. point).
 * 
 * Use the Pythagorean Theorem to compute the length of a right triangle's hypotenuse 
 * (where the end points of that hypotenuse are represented by this and point).
 * 
 * A hypotenuse is the only side of a right triangle which does not form a right angle 
 * with any other side of that triangle.
 * 
 * A hypotenuse is the longest side of a triangle (and a triangle is a three-sided polygon 
 * in which three unique line segments connect three unique points).
 * 
 * // c is the length of a right triangle's hypotenuse.
 * // a is the length of that right triangle's horizontal side.
 * // b is the length of that triangle's vertical side.
 * (c * c) := (a * a) + (b * b). 
 * 
 * // sqrt is a native C++ function defined in the cmath library.
 * c := square_root( (a * a) + (b * b)). 
 */
double POINT::get_distance_from(POINT &amp; point)
{
    int horizontal_difference = 0.0, vertical_difference = 0.0;
    horizontal_difference = X - point.X;
    vertical_difference = Y - point.Y;
    return sqrt((horizontal_difference * horizontal_difference) + (vertical_difference * vertical_difference));
}

/**
 * The getter method of the POINT class returns the slope of the line which intersects 
 * the planar point represented by the caller POINT instance (i.e. this)
 * and the planar point represented by the input POINT instance (i.e. point).
 * 
 * // y := f(x), 
 * // b := f(0), 
 * // f is a function whose input is an x-axis position and whose output is a y-axis position.
 * y := mx + b.
 * 
 * // m is a constant which represents the rate at which y changes as x changes.
 * // y is the output to linear function f. 
 * // b is a constant.
 * m := (y - b) / x. 
 * 
 * // m represents the difference of the y-values divided by the difference of the x-values
 * m := (point_1.y_coordinate - point_0.y_coordinate) / (point_1.x_coordinate - point_0.x_coordinate).
 */
double POINT::get_slope_of_line_to(POINT &amp; point)
{
    double vertical_difference = 0.0, horizontal_difference = 0.0, result = 0.0;
    vertical_difference = point.Y - Y;
    horizontal_difference = point.X - X;
    result = vertical_difference / horizontal_difference;
    if (result == -0) result = 0; // Signed zeros sometimes occur inside of C++ program runtime instances.
    return result;
}

/**
 * The print method of the POINT class prints a description of the caller POINT object to the output stream.
 * 
 * Note that the default value of the function input parameter is the standard command line output stream (std::cout).
 * The default parameter is defined in the POINT class header file (i.e. point.h).
 */
void POINT::print(std::ostream &amp; output)
{
    output &lt;&lt; "\n\n--------------------------------------------------------------------------------------------------";
    output &lt;&lt; "\nthis := " &lt;&lt; this &lt;&lt; ". // The keyword named this is a pointer to the memory address of the first cell of a POINT-sized block of memory cells which are allocated to the instantiation of some POINT-type object.";
    output &lt;&lt; "\n&amp;X = " &lt;&lt; &amp;X &lt;&lt; ". // The operation returns the memory address of the first memory cell of an int-sized block of memory cells which are allocated to the instantiation of some int-type variable named X.";
    output &lt;&lt; "\n&amp;Y = " &lt;&lt; &amp;Y &lt;&lt; ". // The operation returns the memory address of the first memory cell of an int-sized block of memory cells which are allocated to the instantiation of some int-type variable named Y.";    
    output &lt;&lt; "\nsizeof(int) = " &lt;&lt; sizeof(int) &lt;&lt; ". // The operation returns the number of bytes of memory which an int-type variable occupies. Each memory cell has a data capacity of 1 byte.";
    output &lt;&lt; "\nsizeof(POINT) = " &lt;&lt; sizeof(POINT) &lt;&lt; ". // The operation returns the number of bytes of memory which a POINT-type object occupies. Each memory cell has a data capacity of 1 byte.";
    output &lt;&lt; "\nX := " &lt;&lt; X &lt;&lt; ". // X stores an int-type value which represents the horizontal position of a two-dimensional point plotted on a Cartesian grid.";
    output &lt;&lt; "\nY := " &lt;&lt; Y &lt;&lt; ". // Y stores an int-type value which represents the vertical position of a two-dimensional point plotted on a Cartesian grid.";
    output &lt;&lt; "\n--------------------------------------------------------------------------------------------------";
}

/**
 * The friend function is an alternative to the print method.
 * The friend function overloads the ostream operator (&lt;&lt;).
 * 
 * (Overloading an operator is assigning a different function to a native operator other than the function which that operator is used to represent by default).
 * 
 * Note that the default value of the leftmost function input parameter is the standard command line output stream (std::cout).
 * The default parameter is defined in the POINT class header file (i.e. point.h).
 * 
 * The friend function is not a member of the POINT class, but the friend function has access to the private and protected members 
 * of the POINT class and not just the public members of the POINT class.
 * 
 * The friend keyword only prefaces the function prototype for this function (which is declared in the header file named point.h). 
 * The friend keyword does not preface the definition for this function (which is defined immediately below this comment).
 */
std::ostream &amp; operator &lt;&lt; (std::ostream &amp; output, POINT &amp; point)
{
    point.print(output);
    return output;
}

/**
 * The destructor method of the POINT class de-allocates memory which was used to instantiate the POINT object which is calling this function.
 * 
 * The destructor method of the POINT class is implicitly invoked as soon as the program scope in which the caller POINT object was instantiated terminates.
 * In other words, no C++ command is needed to call this function. The destructor is called automatically by the event of the caller object's scope terminating.
 */
POINT::~POINT()
{
    std::cout &lt;&lt; "\n\nDeleting the POINT type object whose memory address is " &lt;&lt; this &lt;&lt; "...";
}
</pre>
<hr>
<p><strong>Program Driver Source Code</strong></p>
<hr>
<p>C++ source file: <a style="background:#000000;color:#00ff00;" href="https://github.com/karlinarayberinger/karlina_object_ultimate_starter_pack/blob/main/point_driver.cpp" target="_blank" rel="noopener">https://github.com/karlinarayberinger/karlina_object_ultimate_starter_pack/blob/main/point_driver.cpp</a></p>
<hr>
<pre>/**
 * file: point_driver.cpp
 * type: C++ (source file)
 * date: 31_JULY_2022
 * author: Karlina Ray Beringer
 * license: PUBLIC_DOMAIN 
 */

#include "point.h" // Include the C++ header file which contains preprocessing directives, variable declarations, and function prototypes for the POINT class.

/** Declare function prototypes (function declarations and not function definitions) which pertain to program unit tests. */
void unit_test_0(std::ostream &amp; output);
void unit_test_1(std::ostream &amp; output);
void unit_test_2(std::ostream &amp; output);
void unit_test_3(std::ostream &amp; output);
void unit_test_4(std::ostream &amp; output);
void unit_test_5(std::ostream &amp; output);
void unit_test_6(std::ostream &amp; output);
void unit_test_7(std::ostream &amp; output);
void unit_test_8(std::ostream &amp; output);
void unit_test_9(std::ostream &amp; output);
void unit_test_10(std::ostream &amp; output);
void unit_test_11(std::ostream &amp; output);

// Unit Test # 0: POINT class default constructor, POINT class print method, and POINT class destructor.
void unit_test_0(std::ostream &amp; output) 
{
    output &lt;&lt; "\n\n--------------------------------------------------------------------------------------------------";
    output &lt;&lt; "\nUnit Test # 0: POINT class default constructor, POINT class print method, and POINT class destructor.";
    output &lt;&lt; "\n--------------------------------------------------------------------------------------------------";
    output &lt;&lt; "\nPOINT point;";
    output &lt;&lt; "\npoint.print(output);";
    POINT point;
    point.print(output);
}

// Unit Test # 1: POINT class default constructor, POINT class print method (with default parameter), and POINT class destructor.
void unit_test_1(std::ostream &amp; output) 
{
    output &lt;&lt; "\n\n--------------------------------------------------------------------------------------------------";
    output &lt;&lt; "\nUnit Test # 1: POINT class default constructor, POINT class print method (with default parameter), and POINT class destructor.";
    output &lt;&lt; "\n--------------------------------------------------------------------------------------------------";
    output &lt;&lt; "\nPOINT point;";
    output &lt;&lt; "\npoint.print(); // Standard command line output (std::cout) is the default parameter for the POINT print method.";
    POINT point;
    point.print(); // Standard command line output (std::cout) is the default parameter for the POINT print method.
}

// Unit Test # 2: POINT class default constructor, POINT class overloaded ostream operator method (which is functionally the same as POINT class print method), and POINT class destructor.
void unit_test_2(std::ostream &amp; output) 
{
    output &lt;&lt; "\n\n--------------------------------------------------------------------------------------------------";
    output &lt;&lt; "\nUnit Test # 2: POINT class default constructor, POINT class overloaded ostream operator method (which is functionally the same as POINT class print method), and POINT class destructor.";
    output &lt;&lt; "\n--------------------------------------------------------------------------------------------------";
    output &lt;&lt; "\nPOINT point;";
    output &lt;&lt; "\noutput &lt;&lt; point; // functionally equivalent to: point.print(output);";
    POINT point;
    output &lt;&lt; point;
}

// Unit Test # 3: POINT class default constructor (using the function explicity rather than implicitly), POINT class overloaded ostream operator method, and POINT class destructor.
void unit_test_3(std::ostream &amp; output) 
{
    output &lt;&lt; "\n\n--------------------------------------------------------------------------------------------------";
    output &lt;&lt; "\nUnit Test # 3: POINT class default constructor (using that function explicity rather than implicitly), POINT class overloaded ostream operator method, and POINT class destructor.";
    output &lt;&lt; "\n--------------------------------------------------------------------------------------------------";
    output &lt;&lt; "\nPOINT point = POINT(); // functionally equivalent to: POINT point;";
    output &lt;&lt; "\noutput &lt;&lt; point;";
    POINT point = POINT();
    output &lt;&lt; point;
}

// Unit Test # 4: POINT class normal constructor (using only valid function inputs), POINT class overloaded ostream operator method, and POINT class destructor.
void unit_test_4(std::ostream &amp; output) 
{
    output &lt;&lt; "\n\n--------------------------------------------------------------------------------------------------";
    output &lt;&lt; "\nUnit Test # 4: POINT class normal constructor (using only valid function inputs), POINT class overloaded ostream operator method, and POINT class destructor.";
    output &lt;&lt; "\n--------------------------------------------------------------------------------------------------";
    output &lt;&lt; "\nPOINT point = POINT(-503,404);";
    output &lt;&lt; "\noutput &lt;&lt; point;";
    POINT point = POINT(-503,404);
    output &lt;&lt; point;
}

// Unit Test # 5: POINT class normal constructor (using only valid function inputs), POINT class overloaded ostream operator method, and POINT class destructor.
void unit_test_5(std::ostream &amp; output) 
{
    output &lt;&lt; "\n\n--------------------------------------------------------------------------------------------------";
    output &lt;&lt; "\nUnit Test # 5: POINT class normal constructor (using only valid function inputs), POINT class overloaded ostream operator method, and POINT class destructor.";
    output &lt;&lt; "\n--------------------------------------------------------------------------------------------------";
    output &lt;&lt; "\nPOINT point_0 = POINT(-999,-999);";
    output &lt;&lt; "\nPOINT point_1 = POINT(999, 999);";
    output &lt;&lt; "\nPOINT point_2 = POINT(-999, 999);";
    output &lt;&lt; "\nPOINT point_3 = POINT(999, -999);";
    output &lt;&lt; "\noutput &lt;&lt; point_0;";
    output &lt;&lt; "\noutput &lt;&lt; point_1;";
    output &lt;&lt; "\noutput &lt;&lt; point_2;";
    output &lt;&lt; "\noutput &lt;&lt; point_3;";
    POINT point_0 = POINT(-999,-999);
    POINT point_1 = POINT(999, 999);
    POINT point_2 = POINT(-999, 999);
    POINT point_3 = POINT(999, -999);
    output &lt;&lt; point_0;
    output &lt;&lt; point_1;
    output &lt;&lt; point_2;
    output &lt;&lt; point_3;
}

// Unit Test # 6: POINT class normal constructor (using both valid and invalid function inputs), POINT class overloaded ostream operator method, and POINT class destructor.
void unit_test_6(std::ostream &amp; output) 
{
    output &lt;&lt; "\n\n--------------------------------------------------------------------------------------------------";
    output &lt;&lt; "\nUnit Test # 6: POINT class normal constructor (using both valid and invalid function inputs), POINT class overloaded ostream operator method, and POINT class destructor.";
    output &lt;&lt; "\n--------------------------------------------------------------------------------------------------";
    output &lt;&lt; "\nPOINT point_0 = POINT(-1000, -999);";
    output &lt;&lt; "\nPOINT point_1 = POINT(999, 1000);";
    output &lt;&lt; "\noutput &lt;&lt; point_0;";
    output &lt;&lt; "\noutput &lt;&lt; point_1;";
    POINT point_0 = POINT(-1000, -999);
    POINT point_1 = POINT(999, 1000);
    output &lt;&lt; point_0;
    output &lt;&lt; point_1;
}

// Unit Test # 7: POINT class normal constructor, POINT class copy constructor, POINT class overloaded ostream operator method, and POINT class destructor.
void unit_test_7(std::ostream &amp; output) 
{
    output &lt;&lt; "\n\n--------------------------------------------------------------------------------------------------";
    output &lt;&lt; "\nUnit Test # 7: POINT class normal constructor, POINT class copy constructor, POINT class overloaded ostream operator method, and POINT class destructor.";
    output &lt;&lt; "\n--------------------------------------------------------------------------------------------------";
    output &lt;&lt; "\nPOINT point_0 = POINT(333, -666);";
    output &lt;&lt; "\nPOINT point_1 = POINT(point_0);";
    output &lt;&lt; "\noutput &lt;&lt; point_0;";
    output &lt;&lt; "\noutput &lt;&lt; point_1;";
    POINT point_0 = POINT(333, -666);
    POINT point_1 = POINT(point_0);
    output &lt;&lt; point_0;
    output &lt;&lt; point_1;
}

// Unit Test # 8: POINT class normal constructor, POINT class distance getter method, POINT class overloaded ostream operator method, and POINT class destructor.
void unit_test_8(std::ostream &amp; output) 
{
    output &lt;&lt; "\n\n--------------------------------------------------------------------------------------------------";
    output &lt;&lt; "\nUnit Test # 8: POINT class normal constructor, POINT class distance getter method, POINT class overloaded ostream operator method, and POINT class destructor.";
    output &lt;&lt; "\n--------------------------------------------------------------------------------------------------";
    output &lt;&lt; "\nPOINT point_0 = POINT(1, 1);";
    output &lt;&lt; "\nPOINT point_1 = POINT(-1, -1);";
    output &lt;&lt; "\noutput &lt;&lt; point_0;";
    output &lt;&lt; "\noutput &lt;&lt; point_1;";
    POINT point_0 = POINT(1, 1);
    POINT point_1 = POINT(-1, -1);
    output &lt;&lt; point_0;
    output &lt;&lt; point_1;
    output &lt;&lt; "\npoint_0.get_distance_from(point_1) = " &lt;&lt; point_0.get_distance_from(point_1) &lt;&lt; ".";
    output &lt;&lt; "\npoint_1.get_distance_from(point_0) = " &lt;&lt; point_1.get_distance_from(point_0) &lt;&lt; ".";
    output &lt;&lt; "\npoint_0.get_distance_from(point_0) = " &lt;&lt; point_0.get_distance_from(point_0) &lt;&lt; ".";
    output &lt;&lt; "\npoint_1.get_distance_from(point_1) = " &lt;&lt; point_1.get_distance_from(point_1) &lt;&lt; ".";
}

// Unit Test # 9: POINT class normal constructor, POINT class distance getter method, POINT class slope getter method, POINT class overloaded ostream operator method, and POINT class destructor.
void unit_test_9(std::ostream &amp; output) 
{
    output &lt;&lt; "\n\n--------------------------------------------------------------------------------------------------";
    output &lt;&lt; "\nUnit Test # 9: POINT class normal constructor, POINT class distance getter method, POINT class slope getter method, POINT class overloaded ostream operator method, and POINT class destructor.";
    output &lt;&lt; "\n--------------------------------------------------------------------------------------------------";
    output &lt;&lt; "\nPOINT point_0 = POINT(0, 4);";
    output &lt;&lt; "\nPOINT point_1 = POINT(3, 0);";
    output &lt;&lt; "\nPOINT point_2 = POINT(0, 0);";
    output &lt;&lt; "\noutput &lt;&lt; point_0;";
    output &lt;&lt; "\noutput &lt;&lt; point_1;";
    output &lt;&lt; "\noutput &lt;&lt; point_2;";
    POINT point_0 = POINT(0, 4);
    POINT point_1 = POINT(3, 0);
    POINT point_2 = POINT(0, 0);
    output &lt;&lt; point_0;
    output &lt;&lt; point_1;
    output &lt;&lt; "\npoint_0.get_distance_from(point_1) = " &lt;&lt; point_0.get_distance_from(point_1) &lt;&lt; ".";
    output &lt;&lt; "\npoint_1.get_distance_from(point_2) = " &lt;&lt; point_1.get_distance_from(point_2) &lt;&lt; ".";
    output &lt;&lt; "\npoint_2.get_distance_from(point_0) = " &lt;&lt; point_2.get_distance_from(point_0) &lt;&lt; ".";
    output &lt;&lt; "\npoint_0.get_slope_of_line_to(point_1) = " &lt;&lt; point_0.get_slope_of_line_to(point_1) &lt;&lt; ".";
    output &lt;&lt; "\npoint_1.get_slope_of_line_to(point_2) = " &lt;&lt; point_1.get_slope_of_line_to(point_2) &lt;&lt; ".";
    output &lt;&lt; "\npoint_2.get_slope_of_line_to(point_0) = " &lt;&lt; point_2.get_slope_of_line_to(point_0) &lt;&lt; ".";
}

// Unit Test # 10: POINT class normal constructor, POINT class data attribute getter methods, POINT class overloaded ostream operator method, and POINT class destructor.
void unit_test_10(std::ostream &amp; output) 
{
    output &lt;&lt; "\n\n--------------------------------------------------------------------------------------------------";
    output &lt;&lt; "\nUnit Test # 10: POINT class normal constructor, POINT class data attribute getter methods, POINT class overloaded ostream operator method, and POINT class destructor.";
    output &lt;&lt; "\n--------------------------------------------------------------------------------------------------";
    output &lt;&lt; "\nPOINT point = POINT(33.3, 88.8);";
    output &lt;&lt; "\noutput &lt;&lt; point;";
    POINT point = POINT(33.3, 88.8);
    output &lt;&lt; point;
    output &lt;&lt; "\npoint.get_X() = " &lt;&lt; point.get_X() &lt;&lt; ".";
    output &lt;&lt; "\npoint.get_Y() = " &lt;&lt; point.get_Y() &lt;&lt; ".";
}

// Unit Test # 11: POINT class normal constructor, POINT class distance getter method, POINT class slope getter method, POINT class overloaded ostream operator method, and POINT class destructor.
void unit_test_11(std::ostream &amp; output) 
{
    output &lt;&lt; "\n\n--------------------------------------------------------------------------------------------------";
    output &lt;&lt; "\nUnit Test # 11: POINT class normal constructor, POINT class distance getter method, POINT class slope getter method, POINT class overloaded ostream operator method, and POINT class destructor.";
    output &lt;&lt; "\n--------------------------------------------------------------------------------------------------";
    output &lt;&lt; "\nPOINT point = POINT(-1, 1);";
    output &lt;&lt; "\noutput &lt;&lt; point;";
    POINT point = POINT(-1, 1);
    output &lt;&lt; point;
    output &lt;&lt; "\npoint.get_distance_from(point) = " &lt;&lt; point.get_distance_from(point) &lt;&lt; ". // point refers to exactly one object";
    output &lt;&lt; "\npoint.get_slope_of_line_to(point) = " &lt;&lt; point.get_slope_of_line_to(point) &lt;&lt; ". // point refers to exactly one object";
}

/** program entry point */
int main()
{
    // Declare a file output stream object.
    std::ofstream file;

    /**
     * Set the number of digits of floating point numbers which are printed to the command line to 50.
     * Set the number of digits of floating point numbers which are printed to the file output stream to 50.
     */
    std::cout.precision(50);
    file.precision(50);

    /**
     * If point_driver_output.txt does not already exist in the same directory as point_driver.cpp, 
     * then create a new file named point_driver_output.txt.
     * 
     * Then open the plain-text file named point_driver_output.txt 
     * and set that file to be overwritten with program data.
     */
    file.open("point_driver_output.txt");

    // Print an opening message to the command line terminal.
    std::cout &lt;&lt; "\n\n--------------------------------";
    std::cout &lt;&lt; "\nStart Of Program";
    std::cout &lt;&lt; "\n--------------------------------";

    // Print an opening message to the file output stream.
    file &lt;&lt; "--------------------------------";
    file &lt;&lt; "\nStart Of Program";
    file &lt;&lt; "\n--------------------------------";

    /** 
     * Run each one of the unit test functions for this program.
     * 
     * Call each unit test function twice such that the first function call prints text results to the command line terminal
     * and the second function call prints text results to the output file stream.
     */
    unit_test_0(std::cout);
    unit_test_0(file);
    unit_test_1(std::cout);
    unit_test_1(file);
    unit_test_2(std::cout);
    unit_test_2(file);
    unit_test_3(std::cout);
    unit_test_3(file);
    unit_test_4(std::cout);
    unit_test_4(file);
    unit_test_5(std::cout);
    unit_test_5(file);
    unit_test_6(std::cout);
    unit_test_6(file);
    unit_test_7(std::cout);
    unit_test_7(file);
    unit_test_8(std::cout);
    unit_test_8(file);
    unit_test_9(std::cout);
    unit_test_9(file);
    unit_test_10(std::cout);
    unit_test_10(file);
    unit_test_11(std::cout);
    unit_test_11(file);

    // Print a closing message to the command line terminal.
    std::cout &lt;&lt; "\n\n--------------------------------";
    std::cout &lt;&lt; "\nEnd Of Program";
    std::cout &lt;&lt; "\n--------------------------------\n\n";

    // Print a closing message to the file output stream.
    file &lt;&lt; "\n\n--------------------------------";
    file &lt;&lt; "\nEnd Of Program";
    file &lt;&lt; "\n--------------------------------";

    // Close the file output stream.
    file.close();

    // Exit the program.
    return 0;
}
</pre>
<hr>
<p><strong>Sample Program Output</strong></p>
<hr>
<p>plain-text file: <a style="background:#000000;color:#ff9000;" href="https://github.com/karlinarayberinger/karlina_object_ultimate_starter_pack/blob/main/point_driver_output.txt" target="_blank" rel="noopener">https://github.com/karlinarayberinger/karlina_object_ultimate_starter_pack/blob/main/point_driver_output.txt</a></p>
<hr>
<pre>--------------------------------
Start Of Program
--------------------------------

--------------------------------------------------------------------------------------------------
Unit Test # 0: POINT class default constructor, POINT class print method, and POINT class destructor.
--------------------------------------------------------------------------------------------------
POINT point;
point.print(output);

--------------------------------------------------------------------------------------------------
this := 0x7ffded1f89f0. // The keyword named this is a pointer to the memory address of the first cell of a POINT-sized block of memory cells which are allocated to the instantiation of some POINT-type object.
&amp;X = 0x7ffded1f89f0. // The operation returns the memory address of the first memory cell of an int-sized block of memory cells which are allocated to the instantiation of some int-type variable named X.
&amp;Y = 0x7ffded1f89f4. // The operation returns the memory address of the first memory cell of an int-sized block of memory cells which are allocated to the instantiation of some int-type variable named Y.
sizeof(int) = 4. // The operation returns the number of bytes of memory which an int-type variable occupies. Each memory cell has a data capacity of 1 byte.
sizeof(POINT) = 8. // The operation returns the number of bytes of memory which a POINT-type object occupies. Each memory cell has a data capacity of 1 byte.
X := 0. // X stores an int-type value which represents the horizontal position of a two-dimensional point plotted on a Cartesian grid.
Y := 0. // Y stores an int-type value which represents the vertical position of a two-dimensional point plotted on a Cartesian grid.
--------------------------------------------------------------------------------------------------

--------------------------------------------------------------------------------------------------
Unit Test # 1: POINT class default constructor, POINT class print method (with default parameter), and POINT class destructor.
--------------------------------------------------------------------------------------------------
POINT point;
point.print(); // Standard command line output (std::cout) is the default parameter for the POINT print method.

--------------------------------------------------------------------------------------------------
Unit Test # 2: POINT class default constructor, POINT class overloaded ostream operator method (which is functionally the same as POINT class print method), and POINT class destructor.
--------------------------------------------------------------------------------------------------
POINT point;
output &lt;&lt; point; // functionally equivalent to: point.print(output);

--------------------------------------------------------------------------------------------------
this := 0x7ffded1f89f0. // The keyword named this is a pointer to the memory address of the first cell of a POINT-sized block of memory cells which are allocated to the instantiation of some POINT-type object.
&amp;X = 0x7ffded1f89f0. // The operation returns the memory address of the first memory cell of an int-sized block of memory cells which are allocated to the instantiation of some int-type variable named X.
&amp;Y = 0x7ffded1f89f4. // The operation returns the memory address of the first memory cell of an int-sized block of memory cells which are allocated to the instantiation of some int-type variable named Y.
sizeof(int) = 4. // The operation returns the number of bytes of memory which an int-type variable occupies. Each memory cell has a data capacity of 1 byte.
sizeof(POINT) = 8. // The operation returns the number of bytes of memory which a POINT-type object occupies. Each memory cell has a data capacity of 1 byte.
X := 0. // X stores an int-type value which represents the horizontal position of a two-dimensional point plotted on a Cartesian grid.
Y := 0. // Y stores an int-type value which represents the vertical position of a two-dimensional point plotted on a Cartesian grid.
--------------------------------------------------------------------------------------------------

--------------------------------------------------------------------------------------------------
Unit Test # 3: POINT class default constructor (using that function explicity rather than implicitly), POINT class overloaded ostream operator method, and POINT class destructor.
--------------------------------------------------------------------------------------------------
POINT point = POINT(); // functionally equivalent to: POINT point;
output &lt;&lt; point;

--------------------------------------------------------------------------------------------------
this := 0x7ffded1f89f0. // The keyword named this is a pointer to the memory address of the first cell of a POINT-sized block of memory cells which are allocated to the instantiation of some POINT-type object.
&amp;X = 0x7ffded1f89f0. // The operation returns the memory address of the first memory cell of an int-sized block of memory cells which are allocated to the instantiation of some int-type variable named X.
&amp;Y = 0x7ffded1f89f4. // The operation returns the memory address of the first memory cell of an int-sized block of memory cells which are allocated to the instantiation of some int-type variable named Y.
sizeof(int) = 4. // The operation returns the number of bytes of memory which an int-type variable occupies. Each memory cell has a data capacity of 1 byte.
sizeof(POINT) = 8. // The operation returns the number of bytes of memory which a POINT-type object occupies. Each memory cell has a data capacity of 1 byte.
X := 0. // X stores an int-type value which represents the horizontal position of a two-dimensional point plotted on a Cartesian grid.
Y := 0. // Y stores an int-type value which represents the vertical position of a two-dimensional point plotted on a Cartesian grid.
--------------------------------------------------------------------------------------------------

--------------------------------------------------------------------------------------------------
Unit Test # 4: POINT class normal constructor (using only valid function inputs), POINT class overloaded ostream operator method, and POINT class destructor.
--------------------------------------------------------------------------------------------------
POINT point = POINT(-503,404);
output &lt;&lt; point;

--------------------------------------------------------------------------------------------------
this := 0x7ffded1f89f0. // The keyword named this is a pointer to the memory address of the first cell of a POINT-sized block of memory cells which are allocated to the instantiation of some POINT-type object.
&amp;X = 0x7ffded1f89f0. // The operation returns the memory address of the first memory cell of an int-sized block of memory cells which are allocated to the instantiation of some int-type variable named X.
&amp;Y = 0x7ffded1f89f4. // The operation returns the memory address of the first memory cell of an int-sized block of memory cells which are allocated to the instantiation of some int-type variable named Y.
sizeof(int) = 4. // The operation returns the number of bytes of memory which an int-type variable occupies. Each memory cell has a data capacity of 1 byte.
sizeof(POINT) = 8. // The operation returns the number of bytes of memory which a POINT-type object occupies. Each memory cell has a data capacity of 1 byte.
X := -503. // X stores an int-type value which represents the horizontal position of a two-dimensional point plotted on a Cartesian grid.
Y := 404. // Y stores an int-type value which represents the vertical position of a two-dimensional point plotted on a Cartesian grid.
--------------------------------------------------------------------------------------------------

--------------------------------------------------------------------------------------------------
Unit Test # 5: POINT class normal constructor (using only valid function inputs), POINT class overloaded ostream operator method, and POINT class destructor.
--------------------------------------------------------------------------------------------------
POINT point_0 = POINT(-999,-999);
POINT point_1 = POINT(999, 999);
POINT point_2 = POINT(-999, 999);
POINT point_3 = POINT(999, -999);
output &lt;&lt; point_0;
output &lt;&lt; point_1;
output &lt;&lt; point_2;
output &lt;&lt; point_3;

--------------------------------------------------------------------------------------------------
this := 0x7ffded1f89d8. // The keyword named this is a pointer to the memory address of the first cell of a POINT-sized block of memory cells which are allocated to the instantiation of some POINT-type object.
&amp;X = 0x7ffded1f89d8. // The operation returns the memory address of the first memory cell of an int-sized block of memory cells which are allocated to the instantiation of some int-type variable named X.
&amp;Y = 0x7ffded1f89dc. // The operation returns the memory address of the first memory cell of an int-sized block of memory cells which are allocated to the instantiation of some int-type variable named Y.
sizeof(int) = 4. // The operation returns the number of bytes of memory which an int-type variable occupies. Each memory cell has a data capacity of 1 byte.
sizeof(POINT) = 8. // The operation returns the number of bytes of memory which a POINT-type object occupies. Each memory cell has a data capacity of 1 byte.
X := -999. // X stores an int-type value which represents the horizontal position of a two-dimensional point plotted on a Cartesian grid.
Y := -999. // Y stores an int-type value which represents the vertical position of a two-dimensional point plotted on a Cartesian grid.
--------------------------------------------------------------------------------------------------

--------------------------------------------------------------------------------------------------
this := 0x7ffded1f89e0. // The keyword named this is a pointer to the memory address of the first cell of a POINT-sized block of memory cells which are allocated to the instantiation of some POINT-type object.
&amp;X = 0x7ffded1f89e0. // The operation returns the memory address of the first memory cell of an int-sized block of memory cells which are allocated to the instantiation of some int-type variable named X.
&amp;Y = 0x7ffded1f89e4. // The operation returns the memory address of the first memory cell of an int-sized block of memory cells which are allocated to the instantiation of some int-type variable named Y.
sizeof(int) = 4. // The operation returns the number of bytes of memory which an int-type variable occupies. Each memory cell has a data capacity of 1 byte.
sizeof(POINT) = 8. // The operation returns the number of bytes of memory which a POINT-type object occupies. Each memory cell has a data capacity of 1 byte.
X := 999. // X stores an int-type value which represents the horizontal position of a two-dimensional point plotted on a Cartesian grid.
Y := 999. // Y stores an int-type value which represents the vertical position of a two-dimensional point plotted on a Cartesian grid.
--------------------------------------------------------------------------------------------------

--------------------------------------------------------------------------------------------------
this := 0x7ffded1f89e8. // The keyword named this is a pointer to the memory address of the first cell of a POINT-sized block of memory cells which are allocated to the instantiation of some POINT-type object.
&amp;X = 0x7ffded1f89e8. // The operation returns the memory address of the first memory cell of an int-sized block of memory cells which are allocated to the instantiation of some int-type variable named X.
&amp;Y = 0x7ffded1f89ec. // The operation returns the memory address of the first memory cell of an int-sized block of memory cells which are allocated to the instantiation of some int-type variable named Y.
sizeof(int) = 4. // The operation returns the number of bytes of memory which an int-type variable occupies. Each memory cell has a data capacity of 1 byte.
sizeof(POINT) = 8. // The operation returns the number of bytes of memory which a POINT-type object occupies. Each memory cell has a data capacity of 1 byte.
X := -999. // X stores an int-type value which represents the horizontal position of a two-dimensional point plotted on a Cartesian grid.
Y := 999. // Y stores an int-type value which represents the vertical position of a two-dimensional point plotted on a Cartesian grid.
--------------------------------------------------------------------------------------------------

--------------------------------------------------------------------------------------------------
this := 0x7ffded1f89f0. // The keyword named this is a pointer to the memory address of the first cell of a POINT-sized block of memory cells which are allocated to the instantiation of some POINT-type object.
&amp;X = 0x7ffded1f89f0. // The operation returns the memory address of the first memory cell of an int-sized block of memory cells which are allocated to the instantiation of some int-type variable named X.
&amp;Y = 0x7ffded1f89f4. // The operation returns the memory address of the first memory cell of an int-sized block of memory cells which are allocated to the instantiation of some int-type variable named Y.
sizeof(int) = 4. // The operation returns the number of bytes of memory which an int-type variable occupies. Each memory cell has a data capacity of 1 byte.
sizeof(POINT) = 8. // The operation returns the number of bytes of memory which a POINT-type object occupies. Each memory cell has a data capacity of 1 byte.
X := 999. // X stores an int-type value which represents the horizontal position of a two-dimensional point plotted on a Cartesian grid.
Y := -999. // Y stores an int-type value which represents the vertical position of a two-dimensional point plotted on a Cartesian grid.
--------------------------------------------------------------------------------------------------

--------------------------------------------------------------------------------------------------
Unit Test # 6: POINT class normal constructor (using both valid and invalid function inputs), POINT class overloaded ostream operator method, and POINT class destructor.
--------------------------------------------------------------------------------------------------
POINT point_0 = POINT(-1000, -999);
POINT point_1 = POINT(999, 1000);
output &lt;&lt; point_0;
output &lt;&lt; point_1;

--------------------------------------------------------------------------------------------------
this := 0x7ffded1f89e8. // The keyword named this is a pointer to the memory address of the first cell of a POINT-sized block of memory cells which are allocated to the instantiation of some POINT-type object.
&amp;X = 0x7ffded1f89e8. // The operation returns the memory address of the first memory cell of an int-sized block of memory cells which are allocated to the instantiation of some int-type variable named X.
&amp;Y = 0x7ffded1f89ec. // The operation returns the memory address of the first memory cell of an int-sized block of memory cells which are allocated to the instantiation of some int-type variable named Y.
sizeof(int) = 4. // The operation returns the number of bytes of memory which an int-type variable occupies. Each memory cell has a data capacity of 1 byte.
sizeof(POINT) = 8. // The operation returns the number of bytes of memory which a POINT-type object occupies. Each memory cell has a data capacity of 1 byte.
X := 0. // X stores an int-type value which represents the horizontal position of a two-dimensional point plotted on a Cartesian grid.
Y := -999. // Y stores an int-type value which represents the vertical position of a two-dimensional point plotted on a Cartesian grid.
--------------------------------------------------------------------------------------------------

--------------------------------------------------------------------------------------------------
this := 0x7ffded1f89f0. // The keyword named this is a pointer to the memory address of the first cell of a POINT-sized block of memory cells which are allocated to the instantiation of some POINT-type object.
&amp;X = 0x7ffded1f89f0. // The operation returns the memory address of the first memory cell of an int-sized block of memory cells which are allocated to the instantiation of some int-type variable named X.
&amp;Y = 0x7ffded1f89f4. // The operation returns the memory address of the first memory cell of an int-sized block of memory cells which are allocated to the instantiation of some int-type variable named Y.
sizeof(int) = 4. // The operation returns the number of bytes of memory which an int-type variable occupies. Each memory cell has a data capacity of 1 byte.
sizeof(POINT) = 8. // The operation returns the number of bytes of memory which a POINT-type object occupies. Each memory cell has a data capacity of 1 byte.
X := 999. // X stores an int-type value which represents the horizontal position of a two-dimensional point plotted on a Cartesian grid.
Y := 0. // Y stores an int-type value which represents the vertical position of a two-dimensional point plotted on a Cartesian grid.
--------------------------------------------------------------------------------------------------

--------------------------------------------------------------------------------------------------
Unit Test # 7: POINT class normal constructor, POINT class copy constructor, POINT class overloaded ostream operator method, and POINT class destructor.
--------------------------------------------------------------------------------------------------
POINT point_0 = POINT(333, -666);
POINT point_1 = POINT(point_0);
output &lt;&lt; point_0;
output &lt;&lt; point_1;

--------------------------------------------------------------------------------------------------
this := 0x7ffded1f89e8. // The keyword named this is a pointer to the memory address of the first cell of a POINT-sized block of memory cells which are allocated to the instantiation of some POINT-type object.
&amp;X = 0x7ffded1f89e8. // The operation returns the memory address of the first memory cell of an int-sized block of memory cells which are allocated to the instantiation of some int-type variable named X.
&amp;Y = 0x7ffded1f89ec. // The operation returns the memory address of the first memory cell of an int-sized block of memory cells which are allocated to the instantiation of some int-type variable named Y.
sizeof(int) = 4. // The operation returns the number of bytes of memory which an int-type variable occupies. Each memory cell has a data capacity of 1 byte.
sizeof(POINT) = 8. // The operation returns the number of bytes of memory which a POINT-type object occupies. Each memory cell has a data capacity of 1 byte.
X := 333. // X stores an int-type value which represents the horizontal position of a two-dimensional point plotted on a Cartesian grid.
Y := -666. // Y stores an int-type value which represents the vertical position of a two-dimensional point plotted on a Cartesian grid.
--------------------------------------------------------------------------------------------------

--------------------------------------------------------------------------------------------------
this := 0x7ffded1f89f0. // The keyword named this is a pointer to the memory address of the first cell of a POINT-sized block of memory cells which are allocated to the instantiation of some POINT-type object.
&amp;X = 0x7ffded1f89f0. // The operation returns the memory address of the first memory cell of an int-sized block of memory cells which are allocated to the instantiation of some int-type variable named X.
&amp;Y = 0x7ffded1f89f4. // The operation returns the memory address of the first memory cell of an int-sized block of memory cells which are allocated to the instantiation of some int-type variable named Y.
sizeof(int) = 4. // The operation returns the number of bytes of memory which an int-type variable occupies. Each memory cell has a data capacity of 1 byte.
sizeof(POINT) = 8. // The operation returns the number of bytes of memory which a POINT-type object occupies. Each memory cell has a data capacity of 1 byte.
X := 333. // X stores an int-type value which represents the horizontal position of a two-dimensional point plotted on a Cartesian grid.
Y := -666. // Y stores an int-type value which represents the vertical position of a two-dimensional point plotted on a Cartesian grid.
--------------------------------------------------------------------------------------------------

--------------------------------------------------------------------------------------------------
Unit Test # 8: POINT class normal constructor, POINT class distance getter method, POINT class overloaded ostream operator method, and POINT class destructor.
--------------------------------------------------------------------------------------------------
POINT point_0 = POINT(1, 1);
POINT point_1 = POINT(-1, -1);
output &lt;&lt; point_0;
output &lt;&lt; point_1;

--------------------------------------------------------------------------------------------------
this := 0x7ffded1f89e8. // The keyword named this is a pointer to the memory address of the first cell of a POINT-sized block of memory cells which are allocated to the instantiation of some POINT-type object.
&amp;X = 0x7ffded1f89e8. // The operation returns the memory address of the first memory cell of an int-sized block of memory cells which are allocated to the instantiation of some int-type variable named X.
&amp;Y = 0x7ffded1f89ec. // The operation returns the memory address of the first memory cell of an int-sized block of memory cells which are allocated to the instantiation of some int-type variable named Y.
sizeof(int) = 4. // The operation returns the number of bytes of memory which an int-type variable occupies. Each memory cell has a data capacity of 1 byte.
sizeof(POINT) = 8. // The operation returns the number of bytes of memory which a POINT-type object occupies. Each memory cell has a data capacity of 1 byte.
X := 1. // X stores an int-type value which represents the horizontal position of a two-dimensional point plotted on a Cartesian grid.
Y := 1. // Y stores an int-type value which represents the vertical position of a two-dimensional point plotted on a Cartesian grid.
--------------------------------------------------------------------------------------------------

--------------------------------------------------------------------------------------------------
this := 0x7ffded1f89f0. // The keyword named this is a pointer to the memory address of the first cell of a POINT-sized block of memory cells which are allocated to the instantiation of some POINT-type object.
&amp;X = 0x7ffded1f89f0. // The operation returns the memory address of the first memory cell of an int-sized block of memory cells which are allocated to the instantiation of some int-type variable named X.
&amp;Y = 0x7ffded1f89f4. // The operation returns the memory address of the first memory cell of an int-sized block of memory cells which are allocated to the instantiation of some int-type variable named Y.
sizeof(int) = 4. // The operation returns the number of bytes of memory which an int-type variable occupies. Each memory cell has a data capacity of 1 byte.
sizeof(POINT) = 8. // The operation returns the number of bytes of memory which a POINT-type object occupies. Each memory cell has a data capacity of 1 byte.
X := -1. // X stores an int-type value which represents the horizontal position of a two-dimensional point plotted on a Cartesian grid.
Y := -1. // Y stores an int-type value which represents the vertical position of a two-dimensional point plotted on a Cartesian grid.
--------------------------------------------------------------------------------------------------
point_0.get_distance_from(point_1) = 2.8284271247461902909492437174776569008827209472656.
point_1.get_distance_from(point_0) = 2.8284271247461902909492437174776569008827209472656.
point_0.get_distance_from(point_0) = 0.
point_1.get_distance_from(point_1) = 0.

--------------------------------------------------------------------------------------------------
Unit Test # 9: POINT class normal constructor, POINT class distance getter method, POINT class slope getter method, POINT class overloaded ostream operator method, and POINT class destructor.
--------------------------------------------------------------------------------------------------
POINT point_0 = POINT(0, 4);
POINT point_1 = POINT(3, 0);
POINT point_2 = POINT(0, 0);
output &lt;&lt; point_0;
output &lt;&lt; point_1;
output &lt;&lt; point_2;

--------------------------------------------------------------------------------------------------
this := 0x7ffded1f89e0. // The keyword named this is a pointer to the memory address of the first cell of a POINT-sized block of memory cells which are allocated to the instantiation of some POINT-type object.
&amp;X = 0x7ffded1f89e0. // The operation returns the memory address of the first memory cell of an int-sized block of memory cells which are allocated to the instantiation of some int-type variable named X.
&amp;Y = 0x7ffded1f89e4. // The operation returns the memory address of the first memory cell of an int-sized block of memory cells which are allocated to the instantiation of some int-type variable named Y.
sizeof(int) = 4. // The operation returns the number of bytes of memory which an int-type variable occupies. Each memory cell has a data capacity of 1 byte.
sizeof(POINT) = 8. // The operation returns the number of bytes of memory which a POINT-type object occupies. Each memory cell has a data capacity of 1 byte.
X := 0. // X stores an int-type value which represents the horizontal position of a two-dimensional point plotted on a Cartesian grid.
Y := 4. // Y stores an int-type value which represents the vertical position of a two-dimensional point plotted on a Cartesian grid.
--------------------------------------------------------------------------------------------------

--------------------------------------------------------------------------------------------------
this := 0x7ffded1f89e8. // The keyword named this is a pointer to the memory address of the first cell of a POINT-sized block of memory cells which are allocated to the instantiation of some POINT-type object.
&amp;X = 0x7ffded1f89e8. // The operation returns the memory address of the first memory cell of an int-sized block of memory cells which are allocated to the instantiation of some int-type variable named X.
&amp;Y = 0x7ffded1f89ec. // The operation returns the memory address of the first memory cell of an int-sized block of memory cells which are allocated to the instantiation of some int-type variable named Y.
sizeof(int) = 4. // The operation returns the number of bytes of memory which an int-type variable occupies. Each memory cell has a data capacity of 1 byte.
sizeof(POINT) = 8. // The operation returns the number of bytes of memory which a POINT-type object occupies. Each memory cell has a data capacity of 1 byte.
X := 3. // X stores an int-type value which represents the horizontal position of a two-dimensional point plotted on a Cartesian grid.
Y := 0. // Y stores an int-type value which represents the vertical position of a two-dimensional point plotted on a Cartesian grid.
--------------------------------------------------------------------------------------------------
point_0.get_distance_from(point_1) = 5.
point_1.get_distance_from(point_2) = 3.
point_2.get_distance_from(point_0) = 4.
point_0.get_slope_of_line_to(point_1) = -1.3333333333333332593184650249895639717578887939453.
point_1.get_slope_of_line_to(point_2) = 0.
point_2.get_slope_of_line_to(point_0) = inf.

--------------------------------------------------------------------------------------------------
Unit Test # 10: POINT class normal constructor, POINT class data attribute getter methods, POINT class overloaded ostream operator method, and POINT class destructor.
--------------------------------------------------------------------------------------------------
POINT point = POINT(33.3, 88.8);
output &lt;&lt; point;

--------------------------------------------------------------------------------------------------
this := 0x7ffded1f89f0. // The keyword named this is a pointer to the memory address of the first cell of a POINT-sized block of memory cells which are allocated to the instantiation of some POINT-type object.
&amp;X = 0x7ffded1f89f0. // The operation returns the memory address of the first memory cell of an int-sized block of memory cells which are allocated to the instantiation of some int-type variable named X.
&amp;Y = 0x7ffded1f89f4. // The operation returns the memory address of the first memory cell of an int-sized block of memory cells which are allocated to the instantiation of some int-type variable named Y.
sizeof(int) = 4. // The operation returns the number of bytes of memory which an int-type variable occupies. Each memory cell has a data capacity of 1 byte.
sizeof(POINT) = 8. // The operation returns the number of bytes of memory which a POINT-type object occupies. Each memory cell has a data capacity of 1 byte.
X := 33. // X stores an int-type value which represents the horizontal position of a two-dimensional point plotted on a Cartesian grid.
Y := 88. // Y stores an int-type value which represents the vertical position of a two-dimensional point plotted on a Cartesian grid.
--------------------------------------------------------------------------------------------------
point.get_X() = 33.
point.get_Y() = 88.

--------------------------------------------------------------------------------------------------
Unit Test # 11: POINT class normal constructor, POINT class distance getter method, POINT class slope getter method, POINT class overloaded ostream operator method, and POINT class destructor.
--------------------------------------------------------------------------------------------------
POINT point = POINT(-1, 1);
output &lt;&lt; point;

--------------------------------------------------------------------------------------------------
this := 0x7ffded1f89f0. // The keyword named this is a pointer to the memory address of the first cell of a POINT-sized block of memory cells which are allocated to the instantiation of some POINT-type object.
&amp;X = 0x7ffded1f89f0. // The operation returns the memory address of the first memory cell of an int-sized block of memory cells which are allocated to the instantiation of some int-type variable named X.
&amp;Y = 0x7ffded1f89f4. // The operation returns the memory address of the first memory cell of an int-sized block of memory cells which are allocated to the instantiation of some int-type variable named Y.
sizeof(int) = 4. // The operation returns the number of bytes of memory which an int-type variable occupies. Each memory cell has a data capacity of 1 byte.
sizeof(POINT) = 8. // The operation returns the number of bytes of memory which a POINT-type object occupies. Each memory cell has a data capacity of 1 byte.
X := -1. // X stores an int-type value which represents the horizontal position of a two-dimensional point plotted on a Cartesian grid.
Y := 1. // Y stores an int-type value which represents the vertical position of a two-dimensional point plotted on a Cartesian grid.
--------------------------------------------------------------------------------------------------
point.get_distance_from(point) = 0. // point refers to exactly one object
point.get_slope_of_line_to(point) = -nan. // point refers to exactly one object

--------------------------------
End Of Program
--------------------------------
</pre>
<hr>
<p>This page was last updated on 31_JULY_2022. The content displayed on this page is licensed as <a style="background:#000000;color:#ff9000;" href="https://karlinaobject.wordpress.com/public_domain/" target="_blank" rel="noopener">PUBLIC_DOMAIN</a> intellectual property.</p>
<hr>	
